{"version":3,"file":"ico.js","sources":["../src/mime.js","../src/browser/image.js","../node_modules/to-data-view/index.js","../src/is-ico.js","../node_modules/decode-ico/index.js","../src/parse/index.js","../src/browser/index.js"],"sourcesContent":["'use strict';\n\nconst MIME_BMP = 'image/bmp';\nconst MIME_JPEG = 'image/jpeg';\nconst MIME_PNG = 'image/png';\n\nmodule.exports = {\n  MIME_BMP,\n  MIME_JPEG,\n  MIME_PNG\n};\n\n","'use strict';\n\nconst { MIME_PNG } = require('../mime');\n\nconst dataURLToArrayBuffer = dataURL => {\n  const string = atob(dataURL.replace(/.+,/, ''));\n  const view = new Uint8Array(string.length);\n  for (let i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n  return view.buffer;\n};\n\nconst Image = {\n  /**\n   * Create imageData from image\n   * @access private\n   * @param {ArrayBuffer} arrayBuffer image buffer\n   * @returns {ImageData} imageData\n   */\n  decode (arrayBuffer) {\n    return new Promise(resolve => {\n      const url = URL.createObjectURL(new Blob([arrayBuffer]));\n      const img = document.createElement('img');\n      img.src = url;\n      img.onload = () => {\n        const { naturalHeight: height, naturalWidth: width } = img;\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const { data } = ctx.getImageData(0, 0, width, height);\n        resolve({\n          data,\n          height,\n          width\n        });\n      };\n    });\n  },\n  /**\n   * Create image from imgData.data\n   * @access private\n   * @param {Object} image data\n   * @param {Number} image.width img width\n   * @param {Number} image.height img height\n   * @param {Uint8ClampedArray} image.data same as imageData.data\n   * @param {String} [mime=image/png] MIME type\n   * @returns {ArrayBuffer} image\n   */\n  encode (image, mime = MIME_PNG) {\n    return new Promise(resolve => {\n      const { data, height, width } = image;\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.createImageData(width, height);\n      const dataData = imageData.data;\n      for (let i = 0; i < dataData.length; i++) {\n        dataData[i] = data[i];\n      }\n      ctx.putImageData(imageData, 0, 0);\n      resolve(dataURLToArrayBuffer(canvas.toDataURL(mime)));\n    });\n  }\n};\n\nmodule.exports = Image;\n","module.exports = function toDataView (data) {\n  if (data instanceof Uint8Array) {\n    return new DataView(data.buffer, data.byteOffset, data.byteLength)\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data)\n  }\n\n  throw new TypeError('Expected `data` to be an ArrayBuffer or Uint8Array')\n}\n","'use strict';\n\nconst toDataView = require('to-data-view');\n\n/**\n * Check the ArrayBuffer is valid ICO.\n * @alias module:ICO\n * @param {ArrayBuffer|Buffer} source ICO file data.\n * @returns {Boolean} True if arg is ICO.\n */\nconst isICO = source => {\n  const dataView = toDataView(source);\n  return dataView.getUint16(0, true) === 0 && dataView.getUint16(2, true) === 1;\n};\n\nmodule.exports = isICO;\n","'use strict'\n\nconst toDataView = require('to-data-view')\n\nfunction makeDivisibleByFour (input) {\n  const rest = input % 4\n\n  return rest ? input + 4 - rest : input\n}\n\nclass Bitmap {\n  constructor (data, offset, props) {\n    this.format = props.format\n    this.offset = offset\n    this.depth = props.colorDepth\n    this.stride = makeDivisibleByFour(props.width * this.depth / 8)\n    this.size = (this.stride * props.height)\n    this.data = data.slice(this.offset, this.offset + this.size)\n\n    if (this.size !== this.data.byteLength) {\n      throw new Error('Truncated bitmap data')\n    }\n  }\n\n  get (x, y, channel) {\n    const idx = this.format.indexOf(channel)\n\n    if (this.depth === 1) {\n      const slice = this.data[(y * this.stride) + (x / 8 | 0)]\n      const mask = 1 << (7 - (x % 8) * 1)\n\n      return (slice & mask) >> (7 - (x % 8) * 1)\n    }\n\n    if (this.depth === 2) {\n      const slice = this.data[(y * this.stride) + (x / 4 | 0)]\n      const mask = 3 << (6 - (x % 4) * 2)\n\n      return (slice & mask) >>> (6 - (x % 4) * 2)\n    }\n\n    if (this.depth === 4) {\n      const slice = this.data[(y * this.stride) + (x / 2 | 0)]\n      const mask = 15 << (4 - (x % 2) * 4)\n\n      return (slice & mask) >>> (4 - (x % 2) * 4)\n    }\n\n    return this.data[(y * this.stride) + (x * (this.depth / 8)) + idx]\n  }\n}\n\nfunction isPng (view, offset) {\n  return (view.getUint32(offset + 0) === 0x89504e47 && view.getUint32(offset + 4) === 0x0d0a1a0a)\n}\n\nfunction pngBitsPerPixel (view, offset) {\n  const bitDepth = view.getUint8(offset + 24)\n  const colorType = view.getUint8(offset + 25)\n\n  if (colorType === 0) return bitDepth * 1\n  if (colorType === 2) return bitDepth * 3\n  if (colorType === 3) return bitDepth * 1\n  if (colorType === 4) return bitDepth * 2\n  if (colorType === 6) return bitDepth * 4\n\n  throw new Error('Invalid PNG colorType')\n}\n\nfunction pngWidth (view, offset) {\n  return view.getUint32(offset + 16, false)\n}\n\nfunction pngHeight (view, offset) {\n  return view.getUint32(offset + 20, false)\n}\n\nfunction decodeTrueColorBmp (data, props) {\n  const colorDepth = props.colorDepth\n  const height = props.height\n  const width = props.width\n\n  if (colorDepth !== 32 && colorDepth !== 24) {\n    throw new Error(`A color depth of ${colorDepth} is not supported`)\n  }\n\n  const xor = new Bitmap(data, 0, { width, height, colorDepth, format: 'BGRA' })\n  const and = (colorDepth === 24)\n    ? new Bitmap(data, xor.offset + xor.size, { width, height, colorDepth: 1, format: 'A' })\n    : null\n\n  const result = new Uint8Array(width * height * 4)\n\n  let idx = 0\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      result[idx++] = xor.get(x, height - y - 1, 'R')\n      result[idx++] = xor.get(x, height - y - 1, 'G')\n      result[idx++] = xor.get(x, height - y - 1, 'B')\n\n      if (colorDepth === 32) {\n        result[idx++] = xor.get(x, height - y - 1, 'A')\n      } else {\n        result[idx++] = and.get(x, height - y - 1, 'A') ? 0 : 255\n      }\n    }\n  }\n\n  return result\n}\n\nfunction decodePaletteBmp (data, props) {\n  const colorCount = props.colorCount\n  const colorDepth = props.colorDepth\n  const height = props.height\n  const width = props.width\n\n  if (colorDepth !== 8 && colorDepth !== 4 && colorDepth !== 2 && colorDepth !== 1) {\n    throw new Error(`A color depth of ${colorDepth} is not supported`)\n  }\n\n  const colors = new Bitmap(data, 0, { width: colorCount, height: 1, colorDepth: 32, format: 'BGRA' })\n  const xor = new Bitmap(data, colors.offset + colors.size, { width, height, colorDepth, format: 'C' })\n  const and = new Bitmap(data, xor.offset + xor.size, { width, height, colorDepth: 1, format: 'A' })\n\n  const result = new Uint8Array(width * height * 4)\n\n  let idx = 0\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const colorIndex = xor.get(x, height - y - 1, 'C')\n\n      result[idx++] = colors.get(colorIndex, 0, 'R')\n      result[idx++] = colors.get(colorIndex, 0, 'G')\n      result[idx++] = colors.get(colorIndex, 0, 'B')\n      result[idx++] = and.get(x, height - y - 1, 'A') ? 0 : 255\n    }\n  }\n\n  return result\n}\n\nfunction decodeBmp (data, iconWidth, iconHeight) {\n  const headerSize = data.getUint32(0, true)\n  const bitmapWidth = (data.getUint32(4, true) / 1) | 0\n  const bitmapHeight = (data.getUint32(8, true) / 2) | 0\n  const colorDepth = data.getUint16(14, true)\n  let colorCount = data.getUint32(32, true)\n\n  if (colorCount === 0 && colorDepth <= 8) {\n    colorCount = (1 << colorDepth)\n  }\n\n  const width = (bitmapWidth === 0 ? iconWidth : bitmapWidth)\n  const height = (bitmapHeight === 0 ? iconHeight : bitmapHeight)\n\n  const bitmapData = new Uint8Array(data.buffer, data.byteOffset + headerSize, data.byteLength - headerSize)\n\n  const result = colorCount\n    ? decodePaletteBmp(bitmapData, { width, height, colorDepth, colorCount })\n    : decodeTrueColorBmp(bitmapData, { width, height, colorDepth })\n\n  return { width, height, data: result, colorDepth }\n}\n\nmodule.exports = function decodeIco (input) {\n  const view = toDataView(input)\n\n  if (view.byteLength < 6) {\n    throw new Error('Truncated header')\n  }\n\n  if (view.getUint16(0, true) !== 0) {\n    throw new Error('Invalid magic bytes')\n  }\n\n  const type = view.getUint16(2, true)\n\n  if (type !== 1 && type !== 2) {\n    throw new Error('Invalid image type')\n  }\n\n  const length = view.getUint16(4, true)\n\n  if (view.byteLength < 6 + (16 * length)) {\n    throw new Error('Truncated image list')\n  }\n\n  return Array.from({ length }, (_, idx) => {\n    const width = view.getUint8(6 + (16 * idx) + 0)\n    const height = view.getUint8(6 + (16 * idx) + 1)\n    const size = view.getUint32(6 + (16 * idx) + 8, true)\n    const offset = view.getUint32(6 + (16 * idx) + 12, true)\n\n    const hotspot = (type !== 2 ? null : {\n      x: view.getUint16(6 + (16 * idx) + 4, true),\n      y: view.getUint16(6 + (16 * idx) + 6, true)\n    })\n\n    if (isPng(view, offset)) {\n      return {\n        bpp: pngBitsPerPixel(view, offset),\n        data: new Uint8Array(view.buffer, view.byteOffset + offset, size),\n        height: pngHeight(view, offset),\n        hotspot,\n        type: 'png',\n        width: pngWidth(view, offset)\n      }\n    }\n\n    const data = new DataView(view.buffer, view.byteOffset + offset, size)\n    const bmp = decodeBmp(data, width, height)\n\n    return {\n      bpp: bmp.colorDepth,\n      data: bmp.data,\n      height: bmp.height,\n      hotspot,\n      type: 'bmp',\n      width: bmp.width\n    }\n  })\n}\n","'use strict';\n\nconst decodeIco = require('decode-ico');\nconst { MIME_PNG } = require('../mime');\n\n/**\n * @typedef {Object} ParsedImage\n * @property {Number} width Image width.\n * @property {Number} height Image height.\n * @property {Number} bpp Image color depth as bits per pixel.\n * @property {ArrayBuffer} buffer Image buffer.\n */\n\n/**\n * Parse ICO and return some image object.\n * @access private\n * @param {ArrayBuffer|Buffer} data ICO file data.\n * @param {String} mime MIME type for output.\n * @param {Object} Image Image encoder/decoder\n * @returns {Promise<ParsedImage[]>} Resolves to an array of {@link ParsedImage}.\n */\nconst parse = (data, mime, Image) => {\n  let icons = null;\n\n  try {\n    icons = decodeIco(data);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const decodePng = icon => {\n    if (icon.type !== 'png') {\n      return Promise.resolve(icon);\n    }\n\n    return Image.decode(icon.data).then(decoded => Object.assign(icon, {\n      data: decoded.data,\n      type: 'bmp'\n    }));\n  };\n\n  const encodeImage = icon => Image.encode(icon, mime).then(encoded => Object.assign(icon, {\n    buffer: encoded,\n    type: mime.replace('image/', '')\n  }));\n\n  const transcodeImage = icon => {\n    if (mime === MIME_PNG && icon.type === 'png') {\n      return Promise.resolve(Object.assign({ buffer: icon.data.buffer.slice(icon.data.byteOffset, icon.data.byteOffset + icon.data.byteLength) }, icon));\n    }\n    return decodePng(icon).then(encodeImage);\n  };\n\n  return Promise.all(icons.map(transcodeImage));\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst Image = require('./image');\nconst isICO = require('../is-ico');\nconst parseICO = require('../parse');\nconst { MIME_PNG } = require('../mime');\n\nconst parse = (arrayBuffer, mime = MIME_PNG) => parseICO(arrayBuffer, mime, Image);\n\nconst ICO = {\n  isICO,\n  parse\n};\n\nmodule.exports = ICO;\n"],"names":["MIME_PNG","require$$0","Image","arrayBuffer","Promise","url","URL","createObjectURL","Blob","img","document","createElement","src","onload","height","naturalHeight","width","naturalWidth","canvas","ctx","getContext","drawImage","data","getImageData","image","mime","imageData","createImageData","dataData","i","length","putImageData","string","atob","dataURL","replace","view","Uint8Array","charCodeAt","buffer","dataURLToArrayBuffer","toDataURL","DataView","byteOffset","byteLength","ArrayBuffer","TypeError","dataView","toDataView","source","getUint16","Bitmap","offset","props","input","rest","format","depth","colorDepth","stride","this","size","slice","Error","x","y","channel","idx","indexOf","decodeBmp","iconWidth","iconHeight","headerSize","getUint32","bitmapWidth","bitmapHeight","colorCount","bitmapData","colors","xor","and","result","colorIndex","get","decodePaletteBmp","decodeTrueColorBmp","type","Array","from","_","getUint8","hotspot","bitDepth","colorType","pngBitsPerPixel","bmp","icons","decodeIco","err","reject","encodeImage","encode","icon","then","Object","assign","encoded","all","map","resolve","decode","decoded","parseICO"],"mappings":"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"}